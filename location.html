<!DOCTYPE html>
<html lang="en">
<head>
    <meta charset="UTF-8">
    <meta name="viewport" content="width=device-width, initial-scale=1.0">
    <title>Enhanced Tracker Pro</title>
    <link rel="stylesheet" href="https://unpkg.com/leaflet@1.7.1/dist/leaflet.css">
    <script src="https://unpkg.com/leaflet@1.7.1/dist/leaflet.js"></script>
    <script type="text/javascript" src="https://cdn.jsdelivr.net/npm/@emailjs/browser@3/dist/email.min.js"></script>
    <style>
        :root {
            --primary-color: #4a90e2;
            --secondary-color: #2c3e50;
            --accent-color: #e74c3c;
            --background-color: #f5f7fa;
            --card-background: #ffffff;
            --success-color: #27ae60;
            --error-color: #c0392b;
            --text-color: #333333;
        }

        * {
            box-sizing: border-box;
            margin: 0;
            padding: 0;
        }

        body {
            font-family: 'Roboto', 'Segoe UI', Tahoma, Geneva, Verdana, sans-serif;
            background-color: var(--background-color);
            color: var(--text-color);
            line-height: 1.6;
        }

        .container {
            max-width: 1200px;
            margin: 0 auto;
            padding: 2rem;
        }

        header {
            background-color: var(--primary-color);
            color: white;
            text-align: center;
            padding: 2rem 0;
            margin-bottom: 2rem;
        }

        h1 {
            font-size: 2.5rem;
            margin-bottom: 0.5rem;
        }

        .subtitle {
            font-size: 1.2rem;
            opacity: 0.8;
        }

        .card {
            background-color: var(--card-background);
            border-radius: 8px;
            box-shadow: 0 4px 6px rgba(0, 0, 0, 0.1);
            padding: 2rem;
            margin-bottom: 2rem;
        }

        h2 {
            color: var(--secondary-color);
            margin-bottom: 1rem;
        }

        button {
            background-color: var(--primary-color);
            color: white;
            border: none;
            padding: 0.8rem 1.5rem;
            font-size: 1rem;
            border-radius: 4px;
            cursor: pointer;
            transition: background-color 0.3s ease;
        }

        button:hover {
            background-color: #3a7bd5;
        }

        button:disabled {
            background-color: #bdc3c7;
            cursor: not-allowed;
        }

        #map {
            height: 400px;
            border-radius: 8px;
            margin-top: 1rem;
        }

        #video {
            width: 100%;
            max-width: 640px;
            border-radius: 8px;
        }

        #canvas {
            display: none;
        }

        #audio {
            width: 100%;
            margin-top: 1rem;
        }

        .status-message {
            margin-top: 1rem;
            padding: 1rem;
            border-radius: 4px;
            font-weight: bold;
        }

        .status-message.success {
            background-color: #d4edda;
            color: var(--success-color);
        }

        .status-message.error {
            background-color: #f8d7da;
            color: var(--error-color);
        }

        .status-message.info {
            background-color: #cce5ff;
            color: #004085;
        }

        @media (max-width: 768px) {
            .container {
                padding: 1rem;
            }

            h1 {
                font-size: 2rem;
            }

            .card {
                padding: 1.5rem;
            }
        }
    </style>
</head>
<body>
    <header>
        <h1>Enhanced Tracker Pro</h1>
        <p class="subtitle">Location, Image, and Audio Tracking System</p>
    </header>

    <div class="container">
        <div class="card">
            <h2>Track and Send Data</h2>
            <button id="sendButton" onclick="startTracking()">Send Location, Image & Audio</button>
            <div id="status"></div>
        </div>

        <div class="card">
            <h2>Location</h2>
            <div id="results"></div>
            <div id="map"></div>
        </div>

        <div class="card">
            <h2>Camera</h2>
            <video id="video" autoplay playsinline></video>
            <button onclick="captureImage()">Capture Image</button>
            <canvas id="canvas"></canvas>
        </div>

        <div class="card">
            <h2>Audio</h2>
            <button id="startRecordingBtn" onclick="startRecording()">Start Audio Recording</button>
            <button id="stopRecordingBtn" onclick="stopRecording()" disabled>Stop Audio Recording</button>
            <audio id="audio" controls></audio>
        </div>
    </div>

    <script>
        let imageDataUrl = "";
        let audioBlob = null;
        let recorder, audioStream;
        let map, marker;
        let watchId;

        (function() {
            emailjs.init("sjem_DYuQ5tWYRZlu");
            initializeCamera();
            initializeMap();
        })();

        function initializeCamera() {
            navigator.mediaDevices.getUserMedia({ video: { facingMode: "environment" } })
                .then(function(stream) {
                    document.getElementById("video").srcObject = stream;
                })
                .catch(function(err) {
                    showStatus("Camera initialization failed: " + err, "error");
                });
        }

        function initializeMap() {
            map = L.map('map').setView([0, 0], 2);
            L.tileLayer('https://{s}.tile.openstreetmap.org/{z}/{x}/{y}.png', {
                attribution: 'Â© OpenStreetMap contributors'
            }).addTo(map);
        }

        function startTracking() {
            if (navigator.geolocation) {
                document.getElementById("sendButton").disabled = true;
                showStatus("Fetching location...", "info");

                watchId = navigator.geolocation.watchPosition(updatePositionAndSend, showError, {
                    enableHighAccuracy: true,
                    timeout: 10000,
                    maximumAge: 0
                });

                setTimeout(() => {
                    if (watchId !== null) {
                        navigator.geolocation.clearWatch(watchId);
                        showStatus("Location tracking stopped after 30 seconds", "info");
                    }
                }, 30000);
            } else {
                showStatus("Geolocation is not supported by this browser.", "error");
            }
        }

        function updatePositionAndSend(position) {
            let latitude = position.coords.latitude;
            let longitude = position.coords.longitude;
            let accuracy = position.coords.accuracy;

            document.getElementById("results").innerHTML = `
                <p><strong>Latitude:</strong> ${latitude.toFixed(6)}</p>
                <p><strong>Longitude:</strong> ${longitude.toFixed(6)}</p>
                <p><strong>Accuracy:</strong> ${accuracy.toFixed(2)} meters</p>
            `;

            map.setView([latitude, longitude], 13);
            if (marker) {
                marker.setLatLng([latitude, longitude]);
            } else {
                marker = L.marker([latitude, longitude]).addTo(map);
            }

            if (accuracy <= 100) {
                navigator.geolocation.clearWatch(watchId);
                sendEmail(latitude, longitude, accuracy);
            } else {
                showStatus(`Waiting for better accuracy (currently ${accuracy.toFixed(2)} meters)`, "info");
            }
        }

        async function sendEmail(lat, lon, accuracy) {
            let localTime = new Date().toLocaleString();
            let imageAttachment = imageDataUrl ? await compressImage(imageDataUrl) : null;
            let audioAttachment = audioBlob ? await compressAudio(audioBlob) : null;

            const emailData = {
                from_name: "Enhanced Tracker Pro",
                message: `Latitude: ${lat}\nLongitude: ${lon}\nAccuracy: ${accuracy} meters\nLocal Time: ${localTime}`,
                image: imageAttachment,
                audio: audioAttachment,
            };

            if (imageAttachment) {
                emailData.image_name = "capture.jpg";
            }

            if (audioAttachment) {
                emailData.audio_name = "audio.mp3";
            }

            showStatus("Sending email with collected data...", "info");

            emailjs.send("service_7ee2uba", "template_b4j0rx4", emailData)
                .then(function(response) {
                    showStatus(`SUCCESS! Data sent. Status: ${response.status}`, "success");
                })
                .catch(function(error) {
                    showStatus(`FAILED! Error sending email: ${error.text}`, "error");
                })
                .finally(function() {
                    document.getElementById("sendButton").disabled = false;
                });
        }

        function captureImage() {
            const video = document.getElementById("video");
            const canvas = document.getElementById("canvas");
            canvas.width = video.videoWidth;
            canvas.height = video.videoHeight;
            canvas.getContext("2d").drawImage(video, 0, 0);
            imageDataUrl = canvas.toDataURL("image/jpeg", 0.7);
            showStatus("Image captured!", "success");
        }

        async function compressImage(dataUrl) {
            return new Promise((resolve) => {
                const img = new Image();
                img.onload = function() {
                    const canvas = document.createElement('canvas');
                    const ctx = canvas.getContext('2d');
                    const maxWidth = 800;
                    const maxHeight = 600;
                    let width = img.width;
                    let height = img.height;

                    if (width > height) {
                        if (width > maxWidth) {
                            height *= maxWidth / width;
                            width = maxWidth;
                        }
                    } else {
                        if (height > maxHeight) {
                            width *= maxHeight / height;
                            height = maxHeight;
                        }
                    }

                    canvas.width = width;
                    canvas.height = height;
                    ctx.drawImage(img, 0, 0, width, height);
                    resolve(canvas.toDataURL('image/jpeg', 0.7).split(',')[1]);
                };
                img.src = dataUrl;
            });
        }

        function startRecording() {
            navigator.mediaDevices.getUserMedia({ audio: true })
                .then(function(stream) {
                    audioStream = stream;
                    recorder = new MediaRecorder(stream);
                    const audioChunks = [];
                    recorder.ondataavailable = function(e) {
                        audioChunks.push(e.data);
                    };
                    recorder.onstop = function() {
                        audioBlob = new Blob(audioChunks, { type: 'audio/wav' });
                        let audioURL = URL.createObjectURL(audioBlob);
                        document.getElementById('audio').src = audioURL;
                    };
                    recorder.start();
                    document.getElementById('startRecordingBtn').disabled = true;
                    document.getElementById('stopRecordingBtn').disabled = false;
                    showStatus("Audio recording started", "success");
                });
        }

        function stopRecording() {
            recorder.stop();
            audioStream.getTracks().forEach(track => track.stop());
            showStatus("Audio recording stopped", "success");
            document.getElementById('startRecordingBtn').disabled = false;
            document.getElementById('stopRecordingBtn').disabled = true;
        }

        async function compressAudio(blob) {
            const audioContext = new (window.AudioContext || window.webkitAudioContext)();
            const arrayBuffer = await blob.arrayBuffer();
            const audioBuffer = await audioContext.decodeAudioData(arrayBuffer);
            
            const offlineContext = new OfflineAudioContext(1, audioBuffer.length, audioBuffer.sampleRate);
            const source = offlineContext.createBufferSource();
            source.buffer = audioBuffer;
            source.connect(offlineContext.destination);
            source.start();
            
            const renderedBuffer = await offlineContext.startRendering();
            const wavBlob = bufferToWave(renderedBuffer, renderedBuffer.length);
            return await blobToBase64(wavBlob);
        }

        function bufferToWave(abuffer, len) {
            const numOfChan = abuffer.numberOfChannels;
            const length = len * numOfChan * 2 + 44;
            const buffer = new ArrayBuffer(length);
            const view = new DataView(buffer);
            let offset = 0;
            const channels = [];
            let i, sample;

            setUint32(0x46464952);
            setUint32(length - 8);
            setUint32(0x45564157);

            setUint32(0x20746d66);
            setUint32(16);
            setUint16(1);
            setUint16(numOfChan);
            setUint32(abuffer.sampleRate);
            setUint32(abuffer.sampleRate * 2 * numOfChan);
            setUint16(numOfChan * 2);
            setUint16(16);

            setUint32(0x61746164);
            setUint32(length - offset - 4);

            for(i = 0; i < abuffer.numberOfChannels; i++)
                channels.push(abuffer.getChannelData(i));

            while(offset < length) {
                for(i = 0; i < numOfChan; i++) {
                    sample = Math.max(-1, Math.min(1, channels[i][offset]));
                    sample = (0.5 + sample < 0 ? sample * 32768 : sample * 32767)|0;
                    view.setInt16(offset * numOfChan * 2 + i * 2, sample, true);
                }
                offset++;
            }

            return new Blob([buffer], {type: "audio/wav"});

            function setUint16(data) {
                view.setUint16(offset, data, true);
                offset += 2;
            }

            function setUint32(data) {
                view.setUint32(offset, data, true);
                offset += 4;
            }
        }

        function blobToBase64(blob) {
            return new Promise((resolve, reject) => {
                const reader = new FileReader();
                reader.onloadend = () => resolve(reader.result.split(',')[1]);
                reader.onerror = reject;
                reader.readAsDataURL(blob);
            });
        }

        function showError(error) {
            let errorMessage;
            switch(error.code) {
                case error.PERMISSION_DENIED:
                    errorMessage = "User denied the request for Geolocation.";
                    break;
                case error.POSITION_UNAVAILABLE:
                    errorMessage = "Location information is unavailable.";
                    break;
                case error.TIMEOUT:
                    errorMessage = "The request to get user location timed out.";
                    break;
                default:
                    errorMessage = "An unknown error occurred.";
                    break;
            }
            showStatus(errorMessage, "error");
            document.getElementById("sendButton").disabled = false;
        }

        function showStatus(message, type) {
            const statusElement = document.getElementById("status");
            statusElement.innerHTML = `<div class="status-message ${type}">${message}</div>`;
        }
    </script>
</body>
</html>
